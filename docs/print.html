<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sistemi e Reti - Architettura del Processore</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Materiale di supporto alle lezioni.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Benvenuti</a></li><li><a href="chap1/01-README.html"><strong aria-hidden="true">2.</strong> Che cos'è un computer?</a></li><li><a href="chap1/02-raspberry.html"><strong aria-hidden="true">3.</strong> Raspberry PI</a></li><li><a href="chap1/03-processore.html"><strong aria-hidden="true">4.</strong> Il Processore</a></li><li><a href="chap1/04-memoria.html"><strong aria-hidden="true">5.</strong> La memoria</a></li><li><a href="chap1/05-somma.html"><strong aria-hidden="true">6.</strong> Somma di interi in C</a></li><li><a href="chap1/06-ALU.html"><strong aria-hidden="true">7.</strong> ALU</a></li><li><a href="chap1/07-hack.html"><strong aria-hidden="true">8.</strong> Hack &amp; Security</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Sistemi e Reti - Architettura del Processore</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#architettura-del-processore" id="architettura-del-processore"><h1>Architettura del processore</h1></a>
<p><strong>A.S. 2018-2019</strong></p>
<p><strong>Istituto di Istruzione Superiore G. Marconi</strong></p>
<p><strong>Sistemi e Reti</strong></p>
<p>Benvenuti ragazzi!</p>
<p>Questo materiale riepiloga quanto detto a lezione negli scorsi giorni.</p>
<p>Le risposte alle domande dei compiti in classe sono tutte incluse in questo materiale.</p>
<p>I riferimenti al libro di testo sono tra parentesi quadre, come ad esempio [pag. 1].</p>
<blockquote>
<p>Il testo in questi box sono per approfondimento. La lettura di questo materiale non è strettamente
necessaria per le verifiche, ma è consigliata per vostra cultura personale e in quanto
sapere indispensabile per chi vuole diventare un informatico.</p>
</blockquote>
<p>Buon studio e buon lavoro.</p>
<a class="header" href="#che-cosè-un-computer" id="che-cosè-un-computer"><h1>Che cos'è un computer?</h1></a>
<p>Prima di parlare del processore, dobbiamo avere bene in mente che cos'è un computer, ed in particolare che cos'è un computer <em>oggi</em> come lo conosciamo noi.</p>
<a class="header" href="#computer--processore--memoria-breve-storia" id="computer--processore--memoria-breve-storia"><h2>Computer = processore + memoria (breve storia)</h2></a>
<p>Volendo semplificare al massimo, i computer che usiamo di solito sono composti da due unità fondamentali <em>distinte</em>:</p>
<ul>
<li><em>processore</em>, che esegue calcoli ed operazioni</li>
<li><em>memoria</em>, che immagazzina le informazioni (dati e istruzioni) che devono essere usate dal processore</li>
</ul>
<p>Questo tipo di divisione ha una storia che percorre tutto il secolo scorso. Nasce dalla macchina ideale di Turing, descritta da <a href="https://it.wikipedia.org/wiki/Alan_Turing">Alan Turing</a> nel 1936. [pagg. 2-3 incluso il box &quot;Macchina di Turing&quot;]</p>
<blockquote>
<p>La storia di Alan Turing è molto interessante, recentemente ne hanno tratto un film chiamato <a href="https://it.wikipedia.org/wiki/The_Imitation_Game">The Imitation Game</a>. Nato a Londra nel 1912, è considerato uno dei padri dell'informatica ed è stato un grande matematico; viene anche considerato il fondatore dell'intelligenza artificiale (molto famoso è il <a href="https://it.wikipedia.org/wiki/Test_di_Turing">Test di Turing</a>, presentato in un articolo del 1950). Curiosità: Turing fu trovato morto l'8 giugno 1954 per avvelenamento nel suo letto, accanto a lui c'era una mela con un morso; probabilmente si trattò di un suicidio a causa della persecuzione legale per omosessualità. Anche se non c'è una fonte ufficiale, si dice che Steve Jobs decise di scegliere la mela morsicata come logo della sua azienda proprio in omaggio a Turing.</p>
</blockquote>
<p>Il modello ideale (cioé non realizzabile nella pratica) di Turing fu ripreso da <a href="https://it.wikipedia.org/wiki/John_von_Neumann">John von Neumann</a> (si legge fòn nòimann) che realizzò nel 1949 la prima macchina digitale programmabile, chiamata EDVAC.</p>
<blockquote>
<p>John von Neumann nacque a Budapest (Ungheria) nel 1903 ma naturalizzato americano dopo il suo trasferimento negli USA a causa delle persecuzione nazista. Anche lui è considerato uno dei padri dell'informatica ed uno dei più importanti scienziati del '900. Il suo contributo alla scienza fa dalla matematica alla statistica, alla fisica quantistica e, ovviamente, all'informatica che stava nascendo proprio in quel periodo. Fu uno dei più grandi sostenitori della bomba atomica e del suo utilizzo militare nel <a href="https://it.wikipedia.org/wiki/Progetto_Manhattan">Progetto Manhattan</a>; questo fervore lo rese una figura controversa nel dopoguerra.</p>
</blockquote>
<p>Ancora oggi la maggior parte dei computer che utilizziamo si basa sull'architettura di Von Neumann: come abbiamo detto all'inizio, l'unità di computazione è nettamente separata da quella di memorizzazione dei dati e delle istruzioni.</p>
<blockquote>
<p>Non tutti i sistemi di elaborazione delle informazioni funzionano con questa separazione: ad esempio, il cervello è costituito da una <em>rete neurale</em> (un insieme di <em>sinapsi</em> collegate fra loro) che ha la funzione sia di processare che di memorizzare le informazioni. Vedi la <a href="./assets/dionisi-bn.pdf">ricerca</a> svolta da Lorenzo Dionisi a riguardo.</p>
</blockquote>
<blockquote>
<p>Può un computer pensare? Domanda molto difficile a cui rispondere, ovviamente. Per sapere lo stato
dell'arte in questo momento sul tema, vi consiglio di seguire il corso <a href="https://www.coursera.org/learn/philosophy">Introduction to Philosophy</a> dell'Università di Edinburgo. Se volete arrivare subito alla parte su mente, cervello e computer, potete saltare direttamente alla settimana 4; vi consiglio comunque di seguire tutto il corso, è molto interessante. Il corso è gratuito, in lingua inglese con sottotitoli disponibili in italiano.</p>
</blockquote>
<a class="header" href="#raspberry-pi" id="raspberry-pi"><h1>Raspberry PI</h1></a>
<p>Nello studio del computer abbiamo la fortuna di poter utilizzare i nostri dispositivi per poter verificare in prima persona
gli argomenti. Per semplicità, per questo corso ho scelto di usare la Raspberry PI, una <em>single-board computer</em> dal prezzo accessibile (circa 40€) e dalle prestazioni adatte alla maggior parte degli usi domestici. L'ultimo modell ad oggi (ottobre 2018) è la Raspberry Pi 3 B+.</p>
<p align="center">
<img title="rpi-fronte" src='./assets/rpi-fronte.jpg' width='70%'>
</p>
<blockquote>
<p>Raspberry Pi è stata sviluppata nel Regno Unito dalla Raspberry Pi Foundation. La presentazione al pubblico è avvenuta il 29 febbraio 2012. E' attualmente la single-board computer più diffusa sul mercato, è molto facile trovare progetti di tutti i tipi che ne fanno uso.</p>
</blockquote>
<p>Single-board computer significa che tutte le componenti del computer sono sulla stessa scheda. Come dicevamo nel capitolo precedente, a noi interessano particolarmente <em>processore</em> e <em>memoria</em>.</p>
<p>Analizziamo la Raspberry: per sapere a cosa corrispondono i vari componenti, possiamo leggere il codice stampato sopra ad ognuno di essi e fare una ricerca su Internet. Dopo una breve ricerca possiamo trovare che il processore è quello cerchiato nell'immagine qui sotto, con la scritta &quot;Broadcom&quot;.</p>
<p align="center">
<img title="rpi-fronte-cpu" src='./assets/rpi-fronte-cpu.jpg' width='70%'>
</p>
<p>Dov'è la RAM? Per trovarla dobbiamo girare la scheda e guardare sul retro. Il chip è quello grande con scritto &quot;Elpida&quot;.</p>
<p align="center">
<img title="rpi-fronte-cpu" src='./assets/rpi-retro.jpg' width='70%'>
</p>
<a class="header" href="#accedere-al-terminale" id="accedere-al-terminale"><h2>Accedere al terminale</h2></a>
<a class="header" href="#raspberry-pi-personale" id="raspberry-pi-personale"><h3>Raspberry PI personale</h3></a>
<p>Se avete a disposizione a casa una Raspberry, potete usarla per questo corso, è la scelta raccomandata.</p>
<p>Se non l'avete già fatto, scaricate e installate il sistema operativo seguendo la <a href="https://www.raspberrypi.org/downloads/raspbian/">guida ufficiale</a>. Avrete bisogno di una scheda SDCard; vi consiglio una scheda da 8, 16 o 32 GB.</p>
<p>Una volta accesa, aprite un terminale premendo sull'icona con lo schermino nero nella barra in alto, a sinistra. Vi comparirà una schermata simile a quella qui sotto.</p>
<p align="center">
<img title=rpi terminal" src='./assets/terminal.png' width='70%'>
</p>
<a class="header" href="#raspberry-pi-remota" id="raspberry-pi-remota"><h3>Raspberry PI remota</h3></a>
<p>Se non avete una Raspberry, potete usare quella della scuola collegandovi via SSH. Potete collegarvi da desktop con Google Chrome o da smartphone con Termius.</p>
<a class="header" href="#desktop" id="desktop"><h4>Desktop</h4></a>
<p>Aprite Chrome e installate l'estensione <a href="https://chrome.google.com/webstore/detail/secure-shell-extension/iodihamcpbpeioajjeobimgagajmlibd">Secure Shell Extension</a>. Vi comparirà l'icona del terminale in alto a destra.</p>
<p align="center">
<img title=rpi terminal" src='./assets/chsh0.png' width='70%'>
</p>
<p>Cliccateci sopra, andate su Connect Dialog, sia aprirà una finestra come quella qui sotto.</p>
<p align="center">
<img title=rpi terminal" src='./assets/chsh.png' width='70%'>
</p>
Inserite username e hostname che vi sono stati forniti a lezione.
<a class="header" href="#smartphone" id="smartphone"><h4>Smartphone</h4></a>
<p>Istruzioni valide sia per iOS (iPhone, iPad) che Android.</p>
<p>Scaricate l'applicazione <a href="https://www.termius.com/">Termius</a> ed apritela.</p>
<p align="center">
<img title=rpi terminal" src='./assets/termius.png' width='30%'>
</p>
<p>Cliccate sul + in basso a destra, quindi &quot;New Host&quot;, come Alias mettere &quot;Raspberry Marconi&quot; e in hostname, username e password quelli che vi sono stati forniti a lezione.</p>
<a class="header" href="#android-in-locale" id="android-in-locale"><h3>Android in locale</h3></a>
<p>Se non avete una Raspberry ma volete comunque fare gli esercizi in locale, senza una connessione Internet, potete  usare un qualsiasi smartphone Android. Vi basta installare l'applicazione <a href="https://termux.com/">Termux</a> per avere un terminale molto simile a quello della Raspberry. Per usare i tasti speciali (es. ctrl, esc, tab, etc.), molto utili da terminale, potete consultare <a href="https://wiki.termux.com/wiki/Touch_Keyboard">questa</a> guida; TL;TR premete la combinazione &quot;Volume up + q&quot;.</p>
<a class="header" href="#computer-linux" id="computer-linux"><h3>Computer Linux</h3></a>
<p>Se avete un computer con il sistema operativo Linux (es. Ubuntu o Mint), potete provare ad usarlo per questo corso. I risultati potrebbero essere un po' diversi ed alcuni comandi potrebbero non funzionare, ma con un po' di buona volontà si riesce a far tutto :)</p>
<a class="header" href="#analisi-software-e-hardware" id="analisi-software-e-hardware"><h2>Analisi software e hardware</h2></a>
<p>Dal terminale voi avete pieno controllo di tutto il sistema della vostra macchina. Cominciamo con richiedere le informazioni essenziali attraverso il seguente comando. <strong>ATTENZIONE</strong>: i comandi nelle guide come questa per convenzione vengono preceduti dal carattere dollaro <code>$</code>, per far capire che è un comando da terminale; voi <strong>non</strong> dovete copiare il dollaro! Tutto ciò che segue e che non è preceduto dal dollaro, è l'output del terminale (cioé quello che viene restituito dal comando).</p>
<pre><code class="language-sh">$ uname -a
Linux raspberrypi 4.9.80-v7+ #1098 SMP Fri Mar 9 19:11:42 GMT 2018 armv7l GNU/Linux
</code></pre>
<p>Analizziamo alcune cose importanti di quello che ci restituisce:</p>
<ul>
<li><code>Linux</code>: kernel del sistema operativo (la parte del sist.operativo a stretto contatto con l'hardware)</li>
<li><code>raspberrypi</code>: nome della nostra macchina che viene visualizzato quando connesso in rete</li>
<li>...</li>
<li><code>armv7l</code>: architettura del processore</li>
<li><code>GNU/Linux</code>: nome completo del sistema operativo</li>
</ul>
<p>Possiamo vedere qui che il processore ha una archiettura di tipo <a href="https://it.wikipedia.org/wiki/Architettura_ARM">ARM</a>.</p>
<blockquote>
<p>Se usate il vostro smartphone Android, avrete dei risultati leggermente diversi ma comunque simili.</p>
</blockquote>
<p>Analizziamo meglio il processore attraverso il comando <code>lscpu</code>:</p>
<pre><code class="language-sh">$ lscpu
Architecture:          armv7l
Byte Order:            Little Endian
CPU(s):                4
On-line CPU(s) list:   0-3
Thread(s) per core:    1
Core(s) per socket:    4
Socket(s):             1
Model:                 4
Model name:            ARMv7 Processor rev 4 (v7l)
CPU max MHz:           1400.0000
CPU min MHz:           600.0000
BogoMIPS:              38.40
Flags:                 half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32
</code></pre>
<p>Qui ci sono tutte le informazioni dettagliate sul processore. In particolare possiamo vedere che il processore ha 4 core (numero di CPU) e una velocità massima di 1400 MHz.</p>
<blockquote>
<p>Su Android, il comando <code>lscpu</code> va installato: se provate a lanciarlo, vi darà le istruzioni per farlo. Di solito si installa lanciando il comando <code>pkg install util-linux</code>. Se non dovesse funzionare, provate prima a lanciare il comando <code>pkg update</code>.</p>
</blockquote>
<a class="header" href="#il-processore" id="il-processore"><h1>Il Processore</h1></a>
<p>Cominciamo ad esaminare come lavora un processore più nel dettaglio.</p>
<p>Prima di tutto va compreso che, anche se può fare cose molto complesse,
il processore sa eseguire ad ogni passo solo operazioni <em>molto semplici</em>.
Volendo estremizzare, il processore fa fondamentalmente le seguenti cose:</p>
<ul>
<li>leggere e scrivere dalla memoria RAM</li>
<li>fare operazioni logiche su numeri binari, ad esempio AND, OR, NOT, etc.</li>
<li>fare operazioni aritmetiche su numeri binari, in particolare la somma</li>
</ul>
<p>Le applicazioni complesse che conosciamo si basano su queste operazioni elementari.
Il vantaggio dei processori è che riescono a fare in un secondo miliardi di queste
operazioni: ad esempio il processore della Raspberry ha un clock di esecuzione di 1.4 GHz,
quindi riesce ad eseguire un miliardo e quattrocento milioni di operazioni in un secondo, più o meno.</p>
<blockquote>
<p>Il cervello funziona in modo molto diverso: ha una frequenza che va da 4 a 40 Hz, ma ad ogni iterazione fa moltissime
operazioni.</p>
</blockquote>
<p>Un'altra cosa fondamentale da capire è che il processore capisce <em>solo numeri binari</em>.
Non esistono nient'altro che uno e zeri all'interno del processore. Questo è dovuto
al fatto che all'interno ci sono collegamenti elettrici e porte logiche, che possono
per l'appunto avere solo i valori di acceso (passa corrente) o spento (non passa corrente).
Tutto quello che non è binario deve essere convertito per poter essere utilizzato.
E' per questo che è fondamentale conoscere bene l'aritmetica binaria per poter
comprendere come funziona una CPU.</p>
<blockquote>
<p>Per impratichirvi con le porte logiche, vi consiglio di giocare a <a href="https://play.google.com/store/apps/details?id=com.Suborbital.CircuitScramble&amp;hl=it">Circuit Scramble</a>. Per iOS non li conosco,
se avete un'app da proporre fatemi sapere che l'aggiungo qui!</p>
</blockquote>
<a class="header" href="#la-memoria" id="la-memoria"><h1>La memoria</h1></a>
<p>Il secondo componente fondamentale dei computer è la <em>memoria</em>.</p>
<p>Prima di tutto una precisazione: quando ora parliamo di memoria, intendiamo un tipo specifico chiamato
<em>memoria primaria</em>: generalmente è costituita dalla RAM, ovvero <em>Random Access Memory</em>, memoria ad accesso casuale.</p>
<div>
<p align="center">
<img title="RAM" src='./assets/ram.png' width='50%'>
</p>
<p align="center">
<em>Diversi tipi di RAM. Fonte: wikipedia</em>
</p>
</div>
<p>La caratteristica principale è che, come dice il nome, si può accedere a qualsiasi parte di questo tipo di memoria
semplicemente conoscendone la posizione, che è rappresentato da un numero intero. Questo numero viene anche detto <em>indirizzo</em>.
Al contrario, altri tipi di memoria come l'hard-disk, devono essere acceduti in maniera <em>sequenziale</em>: per poter accedere ad una certa porzione di memoria, bisogna prima <em>scorrere</em> parte della memoria precedente: questo la rende ovviamente molto più lenta.</p>
<p>Possiamo immaginare la RAM come un lunghissimo nastro, diviso in caselle, proprio come il nastro della macchina di Turing.</p>
<div>
<p align="center">
<img title="Turing machine" src='./assets/turing-machine.jpg' width='70%'>
</p>
<p align="center">
<em>Un esempio di macchina di Turing. Fonte: wikipedia</em>
</p>
</div>
<p>Come dicevamo, la caratteristica di questa memoria è che si può accedere a qualsiasi casella, basta saperne l'indirizzo. Per convenzione e comodità, si usano i numeri esaedecimali per indicare l'indirizzo.</p>
<p>Torniamo al caso della nostra Raspberry. Per sapere la dimensione della memoria, possiamo usare il seguente comando da terminale.</p>
<pre><code>$ cat /proc/meminfo
MemTotal:         949580 kB
MemFree:          335800 kB
MemAvailable:     698964 kB
Buffers:          196460 kB
Cached:           218844 kB
SwapCached:            0 kB
Active:           282936 kB
Inactive:         290512 kB
...
</code></pre>
<blockquote>
<p>Potete eseguire lo stesso comando anche sul vostro dispositivo Android.</p>
</blockquote>
<p>L'output del comando è molto lungo, ho omesso la parte finale per brevità. Il dato che ci interessa in particolare è il primo: memoria totale pari a 949580 kB. Per convertirlo in byte, dobbiamo sapere quanto vale un <code>kB</code>: normalmente il prefisso <code>k</code> sta per kilo e significa 1000, ma in questo caso il kernel (che gestisce <code>/proc/meminfo</code>) usa una convenzione sua e vale 1024 :(.</p>
<p>Calcoliamo il numero totale di byte della memoria, e convertiamolo in esadecimale:</p>
<pre><code>949580 kB = 949580 * 1024 = 972369920 (in base 10) = 0x39F53000 (in base 16)
</code></pre>
<p>Quindi, noi avremo un &quot;nastro&quot; di memoria RAM a cui possiamo accedere usando un indirizzo da 0x00000000 a 0x39F53000.</p>
<p align="center">
<img title="RAM as a tape" src='./assets/ram-tape.png' width='90%'>
</p>
<a class="header" href="#somma-di-interi" id="somma-di-interi"><h1>Somma di interi</h1></a>
<p>Prendiamo come esempio una semplice operazione e proviamo a capire come deve essere trasformata
per poter essere eseguita da un processore.</p>
<p>Ipotizziamo che vogliamo sommare due numeri interi. Come dobbiamo fare? Ricordiamoci che il processore può solo leggere e scrivere sulla
memoria, ed effettuare semplici operazioni. Il processore inizia e finisce in uno stato &quot;vuoto&quot;, quindi tutto quello che deve fare e tutti i dati che usa devono essere già in memoria prima dell'esecuzione del programma.</p>
<p>Proviamo a scomporre in piccoli passi:</p>
<ol>
<li>leggo dalla memoria il primo addendo, e lo copio in un <em>registro interno</em>, ad esempio <code>regA</code></li>
<li>leggo dalla memoria il secondo addendo, e lo copio in un altro <em>registro interno</em>, ad esempio <code>regB</code></li>
<li>leggo dalla memoria l'operazione che devo eseguire, in questo caso somma</li>
<li>eseguo l'operazione</li>
<li>scrivo il risultato in un registro, per ottimizzare posso riutilizzare il <code>regA</code> (così uso solo due registri in totale)</li>
<li>copio il contenuto di <code>regA</code> in memoria.</li>
</ol>
<p>OK, sembra che ci siamo. Proviamo a vedere se funziona effettivamente così. Per verificare,
utilizzeremo il linguaggio C perché è quello che ha meno &quot;passaggi&quot; dal codice sorgente al compilato.</p>
<pre><code class="language-c">int main() {
  int a = 12;
  int b = 32;
  int c = a + b;
  return 0;
}
</code></pre>
<p>Per salvare questo file in locale, utilizzate l'editor <code>nano</code>.</p>
<pre><code class="language-sh">$ nano
</code></pre>
<p>Ricopiate il codice sopra, salvatelo con <code>ctrl-o</code> con il nome <code>main.c</code>, ed uscite dall'editor con <code>ctrl-x</code>.</p>
<blockquote>
<p>Un alternativa più professionale a <code>nano</code> è <code>vim</code>, lo trovate già installato sulla Raspberry. Un tutorial efficace e divertente per imparare a usare vim è <a href="https://vim-adventures.com/">Vim Adventures</a>.</p>
</blockquote>
<p>Ora compiliamo il file con <code>gcc</code> e ci facciamo generare l'assembly con l'opzione <code>-S</code>:</p>
<pre><code class="language-sh">$ gcc -S main.c
</code></pre>
<p>Otteniamo un output simile al seguente:</p>
<pre><code class="language-text">.arch armv6
.eabi_attribute 28, 1
.eabi_attribute 20, 1
.eabi_attribute 21, 1
.eabi_attribute 23, 3
.eabi_attribute 24, 1
.eabi_attribute 25, 1
.eabi_attribute 26, 2
.eabi_attribute 30, 6
.eabi_attribute 34, 1
.eabi_attribute 18, 4
.file	&quot;main.c&quot;
.text
.align	2
.global	main
.syntax unified
.arm
.fpu vfp
.type	main, %function
main:
@ args = 0, pretend = 0, frame = 16
@ frame_needed = 1, uses_anonymous_args = 0
@ link register save eliminated.
str	fp, [sp, #-4]!
add	fp, sp, #0
sub	sp, sp, #20
mov	r3, #12
str	r3, [fp, #-8]
mov	r3, #32
str	r3, [fp, #-12]
ldr	r2, [fp, #-8]
ldr	r3, [fp, #-12]
add	r3, r2, r3
str	r3, [fp, #-16]
mov	r3, #0
mov	r0, r3
add	sp, fp, #0
@ sp needed
ldr	fp, [sp], #4
bx	lr
.size	main, .-main
.ident	&quot;GCC: (Raspbian 6.3.0-18+rpi1+deb9u1)
</code></pre>
<blockquote>
<p>Potete eseguire questi passi anche da Android. Dovrete installare prima gli strumenti di sviluppo con il comando <code>pkg install build-essential</code>.</p>
</blockquote>
<p>La parte che ci interessa è quella all'interno della sezione <code>main:</code>.</p>
<pre><code class="language-text">mov	r3, #12
str	r3, [fp, #-8]
mov	r3, #32
str	r3, [fp, #-12]
ldr	r2, [fp, #-8]
ldr	r3, [fp, #-12]
add	r3, r2, r3
str	r3, [fp, #-16]
</code></pre>
<p>Le operazioni che può eseguire il processore sono quelle più a sinistra:</p>
<ul>
<li><code>mov</code>: move, copia un valore costante in un registro</li>
<li><code>str</code>: store register, copia il valore dal registro alla memoria ad un certo indirizzo</li>
<li><code>ldr</code>: load register, copia il valore dalla memoria al registro ad un certo indirizzo</li>
</ul>
<p>Analizziamo il codice assembly nel dettaglio:</p>
<ul>
<li><code>mov r3, #12</code>: assegna il valore <code>12</code> al registro <code>r3</code></li>
<li><code>str r3, [fp, #-8]</code>: copia il valore del registro <code>r3</code> nell'indirizzo di memoria <code>-8</code></li>
<li><code>mov r3, #32</code>: assegna il valore <code>32</code> al registro <code>r3</code></li>
<li><code>str r3, [fp, #-8]</code>: copia il valore del registro <code>r3</code> nell'indirizzo di memoria <code>-12</code></li>
<li><code>ldr r2, [fp, #-8]</code>: copia il dato all'indirizzo di memoria <code>-8</code> nel registro <code>r2</code></li>
<li><code>ldr r3, [fp, #-12]</code>: copia il dato all'indirizzo di memoria <code>-12</code> nel registro <code>r3</code></li>
<li><code>add r3, r2, r3</code>: effettua la somma dei registri <code>r3</code> e <code>r2</code> ed assegna il risultato a <code>r3</code></li>
<li><code>str r3, [fp, #-16]</code>: copia il valore del registro r3 nell'area di memoria <code>-16</code></li>
</ul>
<p>Concettualmente, è così che funziona un processore: anche le operazioni molto complesse vengono suddivise in piccoli parti
fino ad arrivare ad un risultato molto simile a quello presentato.</p>
<a class="header" href="#arithmetic-logic-unit" id="arithmetic-logic-unit"><h1>Arithmetic Logic Unit</h1></a>
<p>Facciamo un ulteriore passo avanti verso la comprensione di come funziona nel dettaglio l'elaborazione dei dati in un computer. Nella pagina precedente abbiamo visto che uno dei comandi che può interpretare il processore è <code>add</code>.</p>
<p>Ricordiamo ancora una volta che una delle linee guida più importanti nella progettazione del processore è l'efficienza: operazioni molto comuni come la somma deve essere effettuata nel modo più veloce teoricamente possibile. Per questo motivo è stata ideata un'unità dedicata, chiamata Arithmetic Logic Unit (ALU).</p>
<div>
<p align="center">
<img title="ALU" src='./assets/alu.gif' width='90%'>
</p>
<p align="center">
<em>Rappresentazione grafica di una ALU.<br>Fonte: <a href="//commons.wikimedia.org/wiki/User:Lambtron" title="User:Lambtron">Lambtron</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/4.0" title="Creative Commons Attribution-Share Alike 4.0">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=36975996">Link</a></em>
</p>
</div>
<blockquote>
<p>L'idea di ALU è stata proposta da von Neumann stesso insiema al primo computer, EDVAC. La prima implementazione su circuito integrato è del 1967.</p>
</blockquote>
<p>Come funziona in pratica? L'ALU all'interno ha un circuito disegnato appositamente per fare alcune operazioni logiche (es. AND, OR, NOT, XOR) e matematiche (es. somma di binari, complemento a due). Esiste un progetto su Minecraft che spiega nel dettaglio come è possibile realizzare un ALU completamente funzionante usando le pietre rosse (<a href="https://minecraft.gamepedia.com/Redstone_Dust">Redstone</a>) e relativi componenti. Un video di una ALU realizzata in pietra rossa è disponibile <a href="https://www.youtube.com/watch?v=LGkkyKZVzug">qui</a>.</p>
<a class="header" href="#somma-di-interi-1" id="somma-di-interi-1"><h2>Somma di interi</h2></a>
<p>La somma di interi in binario funziona esattamente come la somma in decimale che abbiamo imparato alle elementari, con la sola differenza che:</p>
<ul>
<li>abbiamo solo due simboli disponibili <code>0</code> e <code>1</code> (non dieci)</li>
<li>il riporto deve essere fatto quando si supera il valore <code>1</code> (e non <code>9</code>)</li>
</ul>
<p>Ad esempio:</p>
<pre><code class="language-text">// Quanto fa 6+5?
2 --converto in binario--&gt; 10
3 --converto in binario--&gt; 11

// 1. Metto i numeri in colonna
  10 +
  11 =
------


// 2. Sommo la colonna più a destra
 10 +
 11 =
------
  1

// 3. Passo alla colonna successiva: 1+1 fa 0 col riporto di 1
 10 +
 11 =
------
101   --converto in decimale--&gt; 5  OK, ci torna!

</code></pre>
<a class="header" href="#rappresentazione-dei-numeri-negativi" id="rappresentazione-dei-numeri-negativi"><h2>Rappresentazione dei numeri negativi</h2></a>
<p>Come rappresentiamo i numeri negativi? Ricordiamoci che il processore capisce solo 0 e 1, quindi non abbiamo modo di scrivere il segno &quot;-&quot; davanti ad un numero.</p>
<p>Una soluzione che sembra semplice, ed è stata utilizzata nei primi anni dell'informatica (anni '50 e '60 del secolo scorso) è quella di usare il primo bit del numero come segno. Questo rappresentazione è chiamata <em>complemento a uno</em>. Ipotizziamo di avere una rappresentazione del nostro numero binario a 4 bit:</p>
<pre><code class="language-text">// Primo bit 0, numero positivo
0101  --&gt; +5
// Primo bit 1, numero negativo
1101  --&gt; -5
</code></pre>
<p>Questa rappresentazione ha diversi inconvenienti, principalmente:</p>
<ul>
<li>non è semplicissimo matematicamente fare somme</li>
<li>il valore 0 ha due rappresentazioni: <code>0000</code> e <code>1000</code></li>
</ul>
<a class="header" href="#complemento-a-due" id="complemento-a-due"><h3>Complemento a due</h3></a>
<p>Attualmente tutti i processori e relative ALU utilizzano un altro sistema, chiamata <em>complemento a due</em>. Per rappresentare un numero negativo, si usano i seguenti passi:</p>
<ol>
<li>prendo il valore positivo</li>
<li>inverto tutti i bit</li>
<li>sommo 1</li>
</ol>
<p>Esempio:</p>
<pre><code class="language-text">// Voglio rappresentare il numero -5
// 1. prendo il valore positivo
0101
// 2. inverto i bit
1010
// 3. aggiungo 1
1011
</code></pre>
<p>Quindi la rappresentazione di <code>-5</code> in complemento a due è <code>1011</code>.</p>
<p>Per tornare da rappresentazione binaria in complemento a due a decimale, basta fare l'operazione inversa:</p>
<pre><code class="language-text">// Quanto vale 1001?
// 1. sottraggo 1
1000
// 2. inverto i bit
0111 --&gt; +7
// 3. cambio di segno
+7 --&gt; -7
</code></pre>
<a class="header" href="#somma-con-numeri-negativi" id="somma-con-numeri-negativi"><h2>Somma con numeri negativi</h2></a>
<p>In questo modo fare le somme tra numeri è &quot;gratis&quot;: posso eseguire la somma come abbiamo già imparato, ricordandoci che una sottrazione può sempre essere riscritta come una somma tra numeri con segno.</p>
<pre><code class="language-text">// Quanto fa 7-5?
// La sottrazione può essere riscritta come: 7+(-5)
// Converto i numeri in binario
7 --&gt; 0111
-5 --&gt; 1011
// Eseguo la somma
0111 +
1011 =
------
0010   --&gt; +2    OK, ci torna!
</code></pre>
<blockquote>
<p>Per approfondimenti ed esercizi, vi consiglio di consultare questo <a href="http://chortle.ccsu.edu/assemblytutorial/Chapter-08/ass08_1.html">tutorial</a>.</p>
</blockquote>
<a class="header" href="#hack--security" id="hack--security"><h1>Hack &amp; Security</h1></a>
<p>Come qualsiasi altro componente di un sistema, fisico o software, anche i processori hanno delle vulnerabilità che devono essere conosciute.</p>
<p>Le vulnerabilità dei processori hanno fatto notizia all'inizio di quest'anno
con la divulgazione di due criticità che coinvolgono moltissimi processori attualmente in commercio: Meltdown e Spectre.</p>
<p>Meltdown e Spectre sono chiamati <em>side-channel attacks</em> perché sfruttano l'implementazione fisica di alcuni algoritmi, e si contrappongono principalmente ai <em>brute force attacks</em> che invece si basano, come dice il nome, su attacchi a &quot;forza bruta&quot;.</p>
<p>Meltdown e Spectre si basano su alcune strategie di ottimizzazione del processore. Come abbiamo detto all'inizio di questo capitolo, il numero di operazioni al secondo che può fare un processore equivale più o meno alla sua frequenza, ad esempio 1.2 GHz. Oltre una certa frequenza di esecuzione non si può andare, per motivi fisici e quantistici. Per aumentare le prestazioni si usano quindi altri metodi, in particolare:</p>
<ul>
<li><em>out-of-order processing</em>: le istruzioni vengono riordinate per cercare di eseguirne il più possibile ad ogni ciclo</li>
<li><em>branch prediction</em>: il corpo all'interno dei condizionali (es. <code>if</code>) viene eseguito prima di fare il controllo della condizione stessa, sempre per cercare di fare più operazioni ad ogni ciclo e non lasciare mai il processore sotto-utilizzato.</li>
</ul>
<p>Non tutti i processori usano queste strategie: ad esempio i Cortex-A7 e Cortex-A53 non le usano e non sono quindi vulnerabili a Meltdown e Spectre.</p>
<blockquote>
<p>Per appofondimenti su questo tema, si consiglia caldamente la lettura di <a href="https://www.raspberrypi.org/blog/why-raspberry-pi-isnt-vulnerable-to-spectre-or-meltdown/">questo post</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
